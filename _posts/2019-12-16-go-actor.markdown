---
layout: post
title:  "Go语言的Actor模型的构想与实践"
date:   2019-12-16 22:00:00 +0800
categories: 搞个想法
---

一、Actor是一种对锁编程的解放。

编程中的锁，它的作用就是保护被竞争的资源。但当涉及到具体业务的时候，锁的设计就变得复杂起来，尤其是涉及到超过一个资源的时候，锁和锁之间也很容易产生死结，即死锁。而最麻烦的是，这类型的问题，通常都不太容易在开发阶段发现，所以当发现的时候，通常已经出问题了。锁这么恶心，我们都不想看到锁，但目前来看，锁几乎不可能去掉,锁不会因为你的讨厌而不需要了，那怎么办？
那么干脆把锁隐藏起来吧！
于是人们想办法转移锁的存在方式，锁也慢慢从业务层剥离，转到代码框架的底层中去。例如，现在比较流行的做法是，把业务层的代码变成线程安全的，业务层代码并不直接创建线程来处理异步或并发任务，而是交由语言或库处理，而涉及系统资源相关的部分，也由语言或库充当中间层，为用户代劳了。这些语言或编程框架，已经能让开发人员不接触到锁了。
而角色模型（即Actor Model），正是这么一种并行运算的模型，它不是具体的语言或库，它是一种重要的抽象概念，也是一种”无锁“的编程概念。该模型在1973年于Carl Hewitt、Peter Bishop及Richard Steiger的论文中提出，并影响至今，很多语言和库都受其思想及精神之启发。
角色模型，推崇”一切皆是角色“的哲学，这与面向对象的”一切该是对象“类似，差别在于，面向对象的编程思想，指导的是顺序执行下，对象间的运动和关系；而角色模型的编程思想，指导的是并行执行下，对象间的运动和关系，每个角色都是一个运算实体，它能接收其它角色发来的消息，并且：

1. 发送有限数量的消息给其它消息。
2. 创建有限数量的新角色。
3. 指定接收到下一个消息时的行为。

因为以上操作不含有顺序执行的假设，因此是可以并行进行的。每个角色都是一个独立的实体。虽然从概念上来看，角色内部也可以进行并行运算，但仅限于以上指出的三种行为，而其余行为都应该是顺序的。从一些具体的实现来看，每个角色就是最小的运算单元，每个角色内部的运算并不需要上锁，因为角色内部也就是”原子“的内部了。需要上锁的是角色接收信息的通道，通常都是用一个”无锁“队列来作为这个管道，消息从队列的”头“进入，而每个角色都会分配到一个且仅有一个”线程“，负责从队列的”尾“把消息逐个取出并处理。
基于角色模型，我们得以从”对锁编程“中解放。

二、Actor的消息发送机制

”发送者与已经发送的消息解耦，这是角色模型的根本优势。这允许进行异步通讯，同时满足信息传递的结构控制。“
——Carl Hewitt
这可以理解成，在角色模型定义的世界里面，一切皆是角色，而角色和角色之间，还有消息。每个角色都有自己独立的运动和状态，这些角色本来是互不相关的，而角色之间唯一的关联，就是消息。角色间通过消息的传递来沟通，与此理念不同的是对象间通过调用传递消息，这就像角色间的沟通是”非接触式“的，而对象通过调用的沟通是”接触式“的，后者需要对象”连“在起来，而前者则不会。
不过，以上描述的消息投递有个不足，就是信息都是单向信息传递的，发送消息的角色只管把消息投递到接收消息的角色，从理念上来看并没有什么问题，但从具体业务的角度来看，这就显得不方便了，因为有很多具体的业务，都需要双向信息传递，也就是说，发送者发出消息之后，也想获得接收者发回来的响应消息。
其实这并不是角色模型的问题，但我认为这个是角色模型工具应该为开发人员提供的便利：辅助角色构造”请求-响应“的消息。
因此，我认为角色发出的消息可以有两种，一种是”告知“，即Tell，这是一种单向投递的消息；另一种是”提问-回答“，即Ask-Answer。具体实现上，发送一个Tell消息，只要确认消息投递到对方信箱，则算完成；而发送一个Ask-Answer消息，则需要

角色的实际对象，角色系统内部已经代为管理了，用户需要做的就是：
1. 向角色系统创建自己的角色。
2. 从角色系统中取得对角色的引用。
3. 当角色引用不再需要的时候，调用角色引用的”释放“方法。
