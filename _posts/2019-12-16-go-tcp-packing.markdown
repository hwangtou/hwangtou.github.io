---
layout: post
title:  "用Go语言写个简单的消息队列——TCP数据流的业务层分包"
date:   2019-12-16 22:00:00 +0800
categories: 搞个想法
---

TCP协议是一种流式协议，虽然TCP协议能保证数据在TCP层是可靠传输的，但数据到达业务层也是字节流，TCP层并没有为业务层做数据的分界，这将导致一些问题：
1. 发送方的数据是分开写入到socket的，但实际上接收方收到的数据都是连在一起的。
2. 发送方的数据量超出了socket的缓冲区大小，导致接收方接收超过一次才获得整段数据。

实际上，这些就是TCP流式数据在业务层的“粘包”和“半包”。顺带一提，导致这种粘包半包问题的原因，是socket的缓冲区机制：
1. 当我们写入socket的数据，不是马上就发送到对方，而是会先写入到缓冲区。如果在足够短的时间内，业务层对socket层写入超过一次的数据，那这些数据会依时间先后先写入到缓冲区，然后再一并发送到对方。这就导致了业务层本来看似分开了多次发送的内容，到达接收方的时候变得没有间隔区分。
2. 当我们写入socket的数据过大，数据超出缓冲区的剩余空间的时候，socket会先发送缓冲区中的数据，待缓冲区数据发送完毕，再写入接下来的数据。这就导致业务层本来看似一次发送的内容，达到接收方的时候变得不完整。

要解决业务层粘包和半包，有两种常见的方法：
1. 分隔符——在读字节流遇到特殊的“分隔符”时，则认为包结束。这种方法比较常见，例如我们日常会用到的FTP和SMTP，就是在发送一个命令或一段数据结束后，再加上CRLF来表示。这个方法虽然常见，但有个弱点，发送端要把数据中出现的和“分隔符”一样的字符做一次转义，接收端也要做一次“反”转义，这需要对数据遍历两次。
2. 自定义包——这意味着用户自定义协议，我们需要定义包头Head和包体Body，Head中必须包含整个包的长度信息。 
