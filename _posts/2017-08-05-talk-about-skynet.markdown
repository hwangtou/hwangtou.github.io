---
layout: post
title:  "聊聊skynet"
date:   2018-08-04 22:00:00 +0800
categories: 浅谈感想
---

我觉得也差不多要对我之前的职业生涯作一个小结了，那就聊聊这两年多我接触得最多的一个工具——skynet

我对skynet的接触，最初是上一份工作中，他们需要提高gameserver的效率，而当时我的上司坚持是python的gevent库性能有问题，坚持要我重构这部分的代码。当时给到我的参考就是skynet，skynet的C语言底层部分代码还是挺好读的（虽然和nginx的比起来水平还是差很远），我很快就了解里面的机制，并模仿这套机制用C语言来重构本来的项目的代码，而因为本来的gameserver并没有什么特别的业务，更多是比较纯粹的转发，因此我也没有深入地去了解skynet的lua部分的实现。直到目前这份工作，我需要用skynet来编写游戏服务器端的业务层代码，这才让我对skynet有了更深入一层的了解：

1.  skynet是在模仿erlang来实现一套自己的东西。erlang有自己的一套“进程”的实现，这套“进程”的实现效率高且占用资源少，而skynet则是模仿erlang“进程”，通过自己定制过的luaVM来实现skynet服务。事实上luaVM的单线程等特征，的确比较适合用来模仿erlang进程，但实际上，这个luaVM相对于erlang“进程”来说还是显得有点重。在我们的项目实践下来，一台性能较好的机器大概也只能跑数万个luaVM，即skynet服务，而根据开发过erlang的同事表示，这个配置的机器erlang可以跑过百万的“进程”，足足差了两个数量级。当然，这些都是未经求证的数据，仅供感性认识，不供理性参考。

2. skynet服务，即以上说skynet模仿erlang“进程”的概念，是skynet的思想核心之一。skynet程序的运行，离不开skynet服务的运行和skynet服务之间的通讯。在skynet程序启动的时候，会调用配置文件中的main函数，在这个main函数中，开发者可以对服务进行启动操作。而定义服务代码中，也有服务的start和init等函数，告诉skynet当要启动这个服务的时候，具体应该怎样做。

3. skynet服务间通讯，正因为服务是模仿类似“进程”的概念，那么服务间自然无法通过简单的内存共享之类的方式进行通讯。而skynet提供了类似管道的通讯方式，通过call的方法来进行阻塞式的跨服务调用，这种调用方式会阻塞当前代码直到目标服务返回；通过send的方法可以直接发送一个消息到指定服务，但不会等待对方服务返回。顺便说一个skynet的应用坑——如果你以为call的时候真的会阻塞整个服务就错了，如果有下个事件发送到该服务，服务还是会执行传进来的消息而非阻塞，所以不要以为可以把其当成一个锁机制了。虽然云风不喜欢golang，但者不就是golang的goroutine通讯方式吗？

这一年多实际的skynet开发下来，发现skynet还是有很多问题的，虽然云风说skynet只是一套基本的工具，怎么用还是要看实际用的人，但我觉得如果这个工具真的有心发展好，有些关键的工具还是要提供给开发者的：

1. 更好的服务集群支持：同一个skynet进程的服务可以直接通过服务名称呼叫其它服务，但如果是跨skynet进程的话则麻烦得多。目前项目的方法是，把需要共享的skynet服务的机器地址写到redis中，当这个服务启动的时候set到redis中，当其它服务要呼叫这个服务的时候，则到redis中查找对应的地址，然后用clustermc呼叫对应机器地址的服务。但我觉得这个做法仅仅是能用而已，这种做法不仅不优雅，而且很容易搞错。我则认为可以参考DNS的机制，实现一个集群的Service Name System，服务启动的时候直接道SNS中注册服务，其它服务也可以从SNS中找到对应的服务，这个单独的系统可以确保命名服务的可靠性。

2. 更好的通讯协议支持：skynet最让人诟病的另一个问题，大概就是没有提供TLS等基本的通讯协议支持。不把OpenSSL加到skynet，云风一定能给出千万种理由，但无论理由是什么，结果都是nginx有TLS的支持，有websocket的支持，但在skynet中开发者还要自己去实现一套。如果东西开箱就能用不是更好吗？毕竟我们不是在玩高达，我们要的是东西要用的时候就用得上，而且是可靠的。

3. 更好的服务的定义：其实我觉得skynet对于其服务的定义是很模糊的，skynet的文档比较随性，甚至连其最核心的“服务”也没有好好地给一个定义，大概云风认为用skynet的人，必然都是躺过其它的坑转过来的，所以必然熟悉这些，但自以为大家会懂，这本来就是挖坑的行为。我尤其对服务的生命周期感到疑惑，到底是start先还是init先，不看源码是很难搞清楚的。而且，好像skynet也没有实现服务的关闭功能吧？

也有一些项目实际下来的坑，我觉得不仅是skynet开发中应该注意的：

1. 开发者滥用lua的易用性：虽然lua是一个很容易上手的脚本语言，但不代表我们就应该写出“随心”的代码。面向对象是一个好东西，但这不意味着只有面向对象的语言才能做到面向对象编程，面向对象是一种思想，即使是C语言也可以实现面向对象编程。面向接口编程是一个好东西，只要设计模式不被教条主义般地滥用，面向接口是很必要的。例如扩展一个功能，完全可以考虑策略模式和装饰器模式，而不是直接把相关的代码直接添加到函数中，这样后来的人会很困扰诶，你知道吗？

2. 游戏项目想办法解决配置的检查问题：当我们接手一个功能的时候，最头疼的就是配置文件报错的问题，因为程序和策划的职能分家的问题，我们的策划都是通过excel的方式配置游戏中的参数，然后通过工具转换成lua文件，但是因为lua的脚本性，只有执行到具体的配置才会出错，策划经常会因为理解问题出现配置错漏，这样的话程序根本很难跑起来，但实际上，我认为配置这个应该是在开发的时候就应该把对应的配置的检查方式加到代码中，让skynet程序启动的时候先跑一个服务把错误的配置清单列出，并指出错误的地方。
